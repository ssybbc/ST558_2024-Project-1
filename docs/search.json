[
  {
    "objectID": "Project 1.html",
    "href": "Project 1.html",
    "title": "ST558-Project 1",
    "section": "",
    "text": "Census data is of a great interest of statisticians, but it could be challenging to get data from API. Let’s first try the example call:\n\nlibrary (dplyr)\n\nWarning: package 'dplyr' was built under R version 4.3.1\n\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary (jsonlite)\n\n\nbase_url_trial &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums\"\nquery_params &lt;- list(\n  get = \"SEX,PWGTP,MAR\",   # Fields to retrieve\n  SCHL = \"24\",             # Filter\n  key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\"  # API key\n)\nPUMS_trial &lt;- httr::GET(url = base_url_trial, query = query_params)\nPUMS_trial_parsed &lt;- fromJSON(rawToChar(PUMS_trial$content))\nstr (PUMS_trial_parsed)\n\n chr [1:44080, 1:4] \"SEX\" \"2\" \"2\" \"1\" \"1\" \"1\" \"1\" \"2\" \"1\" \"2\" \"2\" \"1\" \"2\" ...\n\n\nThen we turn the PUMS_trial into a tibble\n\nPUMS_trial_tibble &lt;- as_tibble (PUMS_trial_parsed)\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\nhead (PUMS_trial_tibble)\n\n# A tibble: 6 × 4\n  V1    V2    V3    V4   \n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1 SEX   PWGTP MAR   SCHL \n2 2     6     5     24   \n3 2     23    2     24   \n4 1     23    3     24   \n5 1     80    5     24   \n6 1     16    1     24   \n\n\nWow, that was successful. So the key was to put the conditions in the query argument in the function GET()."
  },
  {
    "objectID": "Project 1.html#select-functions-enabling-the-selection-of-year.",
    "href": "Project 1.html#select-functions-enabling-the-selection-of-year.",
    "title": "ST558-Project 1",
    "section": "Select functions enabling the selection of year.",
    "text": "Select functions enabling the selection of year.\nWe wanted to customize a function that enable custom-selection of Year of survey with default at 2022. That must have something to do with the URL we are inquiring. Let’s stick to the variable settings in the trial and play with the year of survey first.\n\ngetPUMS &lt;- function (year = 2022) {\n  base_url &lt;- paste0 (\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums\")\n  \n  query_params &lt;- list(\n  get = \"SEX,PWGTP,MAR,AGEP\",   \n  SCHL = \"24\",             \n  key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\") \n  \n  PUMScust &lt;- httr::GET(url = base_url, query = query_params)\n  PUMScust_parsed &lt;- fromJSON(rawToChar(PUMScust$content))\n  PUMScust_tibble &lt;- as_tibble (PUMScust_parsed)\n  return (head (PUMScust_tibble))\n}\ngetPUMS (2022)\n\n# A tibble: 6 × 5\n  V1    V2    V3    V4    V5   \n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1 SEX   PWGTP MAR   AGEP  SCHL \n2 2     6     5     88    24   \n3 2     23    2     84    24   \n4 1     23    3     57    24   \n5 1     80    5     37    24   \n6 1     16    1     82    24   \n\n\nIt looks like worked. Let’s see whether it worked on other years.\n\ngetPUMS (2021)\n\n# A tibble: 6 × 5\n  V1    V2    V3    V4    V5   \n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1 SEX   PWGTP MAR   AGEP  SCHL \n2 1     118   3     71    24   \n3 1     20    3     49    24   \n4 2     9     5     81    24   \n5 1     13    1     94    24   \n6 2     38    5     86    24   \n\ngetPUMS (2019)\n\n# A tibble: 6 × 5\n  V1    V2    V3    V4    V5   \n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1 SEX   PWGTP MAR   AGEP  SCHL \n2 2     6     5     83    24   \n3 1     14    5     40    24   \n4 1     17    3     53    24   \n5 1     16    5     28    24   \n6 1     23    1     59    24   \n\n\nThey all worked. I also noticed that if year=2020, will return an error. It turned out the ACS 1-Year PUMS data for the year 2020 was not included in the default path because of smaller-than-previous sample issue."
  },
  {
    "objectID": "Project 1.html#make-a-function-that-specifies-the-numeric-values-to-be-returned.",
    "href": "Project 1.html#make-a-function-that-specifies-the-numeric-values-to-be-returned.",
    "title": "ST558-Project 1",
    "section": "Make a function that specifies the numeric values to be returned.",
    "text": "Make a function that specifies the numeric values to be returned.\nNext we wanted to make a function that solely tells which numeric values to be returned. Default was AGEP and PWGTP, with several options being available.\n\nchoosenum &lt;- function (numvarinput) {\n  \n  numvar &lt;- ifelse (numvarinput %in% c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWAP\", \"JWMNP\"),\n             c(numvarinput, \"PWGTP\"), \n             \"error: numeric variable must match with exisiting numeric variable names\")\n  return (numvar)\n  \n}\nchoosenum (\"AGEP\")\n\n[1] \"AGEP\"\n\nchoosenum (\"\")\n\n[1] \"error: numeric variable must match with exisiting numeric variable names\"\n\n\nIt is weird no matter what I input, the choosenum function always returns an one-element vector. It turns out this is the setting of ifelse syntax. Try if-else sentence instead.\n\nchoosenum &lt;- function (numvarinput) {\n  if (numvarinput %in% c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWAP\",\"JWDP\", \"JWMNP\"))\n  {numvar &lt;- c (numvarinput, \"PWGTP\")}\n  else {numvar &lt;- \"Error\"}\n  return (numvar)\n}\nchoosenum (\"GASP\")\n\n[1] \"GASP\"  \"PWGTP\"\n\nchoosenum (\"\")\n\n[1] \"Error\"\n\n\nIt returns a string of two characters and takes both my input and another variant PWGTP. Now try “attaching” the new function with our main function getPUMS ()\n\ngetPUMSv2 &lt;- function (year = 2022, numvarinput = \"AGEP\") {\n  base_url &lt;- paste0 (\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums\")\n    query_params &lt;- list(\n    get = paste0 (choosenum(numvarinput)[1],\",\",choosenum(numvarinput)[2]),\n    SCHL = \"24\",\n    key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\") \n  PUMScust &lt;- httr::GET(url = base_url, query = query_params)\n  PUMScust_parsed &lt;- fromJSON(rawToChar(PUMScust$content))\n  PUMScust_tibble &lt;- as_tibble (PUMScust_parsed)\n  return (head (PUMScust_tibble))\n}\ngetPUMSv2(2022, \"GASP\")\n\n# A tibble: 6 × 3\n  V1    V2    V3   \n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1 GASP  PWGTP SCHL \n2 3     6     24   \n3 3     23    24   \n4 3     23    24   \n5 3     80    24   \n6 3     16    24   \n\n\nWhat happens if I don’t choose any numeric values?\n\ngetPUMSv2(2022)\n\n# A tibble: 6 × 3\n  V1    V2    V3   \n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1 AGEP  PWGTP SCHL \n2 88    6     24   \n3 84    23    24   \n4 57    23    24   \n5 37    80    24   \n6 82    16    24   \n\n\nThis is cool. This way ensures the numeric input must have a value. Now if you look closely at the objects returned by the getPUMSv2 function, these variables are all character variables. Make them numeric now!\n\ngetPUMSv2.1 &lt;- function (year = 2022, numvarinput) {  \n  base_url &lt;- paste0 (\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums\")\n  \n  query_params &lt;- list(\n  get = paste0 (choosenum(numvarinput)[1],\",\",choosenum(numvarinput)[2]),\n                SCHL = \"24\",\n                key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\") \n  \n  PUMScust &lt;- httr::GET(url = base_url, query = query_params)\n  PUMScust_parsed &lt;- fromJSON(rawToChar(PUMScust$content))\n  PUMScust_tibble &lt;- as_tibble (PUMScust_parsed)\n  PUMScust_tibble &lt;- mutate (PUMScust_tibble, PWGTP_n = as.numeric(PUMScust_tibble$PWGTP))\n    return (head (PUMScust_tibble))\n}\ngetPUMSv2.1(2022, \"GASP\")\n\nAttempt to fix the error that might be due to missing values for PUMScust_tibble$PWGTP\n\n# WT: Not yet fixed\ngetPUMSv2.1b &lt;- function (year = 2022, numvarinput = \"AGEP\") {  \n  base_url &lt;- paste0(\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums\")\n  \n  query_params &lt;- list(\n  get = paste0(choosenum(numvarinput)[1],\",\",choosenum(numvarinput)[2]),\n                SCHL = \"24\",\n                key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\") \n  \n  PUMScust &lt;- httr::GET(url = base_url, query = query_params)\n  PUMScust_parsed &lt;- fromJSON(rawToChar(PUMScust$content))\n  PUMScust_tibble &lt;- as_tibble(PUMScust_parsed)\n  PUMScust_tibble &lt;- mutate(PUMScust_tibble, PWGTP_n = as.numeric(as.character(PUMScust_tibble$PWGTP)))\n    return(head(PUMScust_tibble))\n}\ngetPUMSv2.1b(2022, \"GASP\")\n\nWe fixed the issue of column names in the below updated function getPUMSv2.1c\n\n# WT: issue related to mutate() is fixed. Column names are good. Function is getPUMSv2.1c\ngetPUMSv2.1c &lt;- function(year = 2022, numvarinput = \"AGEP\"){\n  base_url &lt;- paste0(\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums\")\n  query_params &lt;- list(\n  get = paste0(choosenum(numvarinput)[1],\",\",choosenum(numvarinput)[2]),\n                SCHL = \"24\",\n                key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\") \n  \n  PUMScust &lt;- httr::GET(url = base_url, query = query_params)\n  PUMScust_parsed &lt;- fromJSON(rawToChar(PUMScust$content))\n  PUMScust_tibble &lt;- as_tibble(PUMScust_parsed)\n# Address the error where the first row of PUMScust_tibble is mistakenly considered data, which should be the column names.\n# Set first row as column names\n  # Function \"unlist\" turns the first row of data into a vector.\n  colnames(PUMScust_tibble) &lt;- as.character(unlist(PUMScust_tibble[1,]))\n# Remove the first row\n  PUMScust_tibble &lt;- PUMScust_tibble[-1,]\n# convert column to appropriate data type (int)\n  PUMScust_tibble &lt;- type.convert(PUMScust_tibble, as.is = TRUE)\n# create a column with numeric value for PWGTP (double)\n  PUMScust_tibble &lt;- mutate (PUMScust_tibble, PWGTP_n = as.numeric(PUMScust_tibble$PWGTP))\n  return(head(PUMScust_tibble,9))\n}\ngetPUMSv2.1c(2022, \"GASP\")\n\n# A tibble: 9 × 4\n   GASP PWGTP  SCHL PWGTP_n\n  &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;dbl&gt;\n1     3     6    24       6\n2     3    23    24      23\n3     3    23    24      23\n4     3    80    24      80\n5     3    16    24      16\n6     3   107    24     107\n7     3    10    24      10\n8     3    22    24      22\n9     3   127    24     127\n\n\nWe noticed that there is a redundant column caused by mutate function, which we will drop later. Now go ahead to test other numeric variables to see if they work.\n\ngetPUMSv2.1c(2022, \"GRPIP\")\n\n# A tibble: 9 × 4\n  GRPIP PWGTP  SCHL PWGTP_n\n  &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;dbl&gt;\n1     0     6    24       6\n2     0    23    24      23\n3     0    23    24      23\n4     0    80    24      80\n5     0    16    24      16\n6     0   107    24     107\n7     0    10    24      10\n8     0    22    24      22\n9     0   127    24     127\n\ngetPUMSv2.1c(2022, \"JWAP\")\n\n# A tibble: 9 × 4\n   JWAP PWGTP  SCHL PWGTP_n\n  &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;dbl&gt;\n1     0     6    24       6\n2     0    23    24      23\n3    58    23    24      23\n4     0    80    24      80\n5     0    16    24      16\n6     0   107    24     107\n7     0    10    24      10\n8     0    22    24      22\n9   121   127    24     127\n\n\n\ngetPUMSv2.1c(2022, \"JWDP\")\n\n# A tibble: 9 × 4\n   JWDP PWGTP  SCHL PWGTP_n\n  &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;dbl&gt;\n1     0     6    24       6\n2     0    23    24      23\n3    19    23    24      23\n4     0    80    24      80\n5     0    16    24      16\n6     0   107    24     107\n7     0    10    24      10\n8     0    22    24      22\n9    79   127    24     127\n\n\n\ngetPUMSv2.1c(2022, \"JWMNP\")\n\n# A tibble: 9 × 4\n  JWMNP PWGTP  SCHL PWGTP_n\n  &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;dbl&gt;\n1     0     6    24       6\n2     0    23    24      23\n3     2    23    24      23\n4     0    80    24      80\n5     0    16    24      16\n6     0   107    24     107\n7     0    10    24      10\n8     0    22    24      22\n9    10   127    24     127\n\n\nThe problem is the time is changed into the correct format. Need to think of ways to decode the time code (see the last function getPUMSsum for a resolution)\nNow, move on to the next topic."
  },
  {
    "objectID": "Project 1.html#make-a-function-that-specifies-the-categorical-variables-to-be-returned.",
    "href": "Project 1.html#make-a-function-that-specifies-the-categorical-variables-to-be-returned.",
    "title": "ST558-Project 1",
    "section": "Make a function that specifies the categorical variables to be returned.",
    "text": "Make a function that specifies the categorical variables to be returned.\nSimilarly, for categorical variables, we wanted to make a function that solely tells which character values to be returned. Default was SEX, with several options being available.\n\nchoosecat &lt;- function (catvarinput= \"SEX\") {\n  if (catvarinput %in% c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\"))\n  {catvar &lt;- catvarinput}\n  else {catvar &lt;- \"Error\"}\n  return (catvar)\n}\nchoosecat (\"FER\")\n\n[1] \"FER\"\n\n\nThe previous code did not the correct factor. WT: We updated the above code as follows. Function is choosecatv2\n\n# WT: modified the above code to turn variable into levels, one categorical variable must be returned. Level and label information is from the variable website, link provided in the project instructions.\nchoosecatv2 &lt;- function (catvarinput = \"SEX\"){\n  if (catvarinput %in% c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\")){\n    catvar &lt;- switch(catvarinput,\n        \"SEX\" = factor(c(1, 2), levels = c(1, 2), labels = c(\"Male\", \"Female\")),\n        \"FER\" = factor(c(1, 2), levels = c(1, 2), labels = c(\"Has given birth\", \"Has not given birth\")),\n        \"HHL\" = factor(c(1, 2, 3, 4, 5), levels = c(1, 2, 3, 4, 5),\n                labels = c(\"English only\", \"Spanish\", \"Other Indo-European languages\", \"Asian/Pacific Island languages\", \"Other language\")),\n        \"HISPEED\" = factor(c(1, 2), levels = c(1, 2), labels = c(\"Yes\", \"No\")),\n        \"JWTRNS\" = factor(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), \n               levels = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12),\n               labels = c(\"Car, truck, or van\", \"Bus\", \"Subway or elevated rail\", \"Long-distance train or commuter rail\", \"Light rail, streetcar, or trolley\", \"Ferryboat\", \"Taxicab\", \"Motorcycle\", \"Bicycle\", \"Walked\", \"Worked from home\", \"Other method\")),\n        \"SCH\" = factor(c(1, 2, 3), levels = c(1, 2, 3), labels = c(\"No, has not attended in the last 3 months\", \"Yes, public school or public college\", \"Yes, private school or college or home school\")),\n        \"SCHL\" = factor(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24), levels = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24), labels = c(\"No schooling completed\", \"Nursery school, preschool\", \"Kindergarten\", \"Grade 1\", \"Grade 2\", \"Grade 3\", \"Grade 4\", \"Grade 5\", \"Grade 6\", \"Grade 7\", \"Grade 8\", \"Grade 9\", \"Grade 10\", \"Grade 11\", \"12th grade - no diploma\", \"Regular high school diploma\", \"GED or alternative credential\", \"Some college, but less than 1 year\", \"1 or more years of college credit, no degree\", \"Associate's degree\", \"Bachelor's degree\", \"Master's degree\", \"Professional degree beyond a bachelor's degree\", \"Doctorate degree\"))  \n    )\n  } else {\n     catvar &lt;- \"Error: Invalid input variable\"\n  }\n  return(catvar)\n  }\n  \n# calling the following function will return the details for the categorical variable\nchoosecatv2(\"HHL\")\n\n[1] English only                   Spanish                       \n[3] Other Indo-European languages  Asian/Pacific Island languages\n[5] Other language                \n5 Levels: English only Spanish ... Other language\n\nchoosecatv2(\"SCHL\")\n\n [1] No schooling completed                        \n [2] Nursery school, preschool                     \n [3] Kindergarten                                  \n [4] Grade 1                                       \n [5] Grade 2                                       \n [6] Grade 3                                       \n [7] Grade 4                                       \n [8] Grade 5                                       \n [9] Grade 6                                       \n[10] Grade 7                                       \n[11] Grade 8                                       \n[12] Grade 9                                       \n[13] Grade 10                                      \n[14] Grade 11                                      \n[15] 12th grade - no diploma                       \n[16] Regular high school diploma                   \n[17] GED or alternative credential                 \n[18] Some college, but less than 1 year            \n[19] 1 or more years of college credit, no degree  \n[20] Associate's degree                            \n[21] Bachelor's degree                             \n[22] Master's degree                               \n[23] Professional degree beyond a bachelor's degree\n[24] Doctorate degree                              \n24 Levels: No schooling completed Nursery school, preschool ... Doctorate degree\n\n\nNow let’s concatenate this sub function into the original function and setting up the default categorical variable input as “SEX”.\n\ngetPUMSv3 &lt;- function (year = 2022, numvarinput = \"AGEP\", catvarinput = \"SEX\") {\n  base_url &lt;- paste0 (\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums\")\n  query_params &lt;- list(\n    get = paste0 (choosenum(numvarinput)[1],\",\",choosenum(numvarinput)[2],\",\",choosecat(catvarinput)),\n    SCHL = \"24\",\n    key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\")\n  PUMScust &lt;- httr::GET(url = base_url, query = query_params)\n  PUMScust_parsed &lt;- fromJSON(rawToChar(PUMScust$content))\n  PUMScust_tibble &lt;- as_tibble (PUMScust_parsed)\n  return (head (PUMScust_tibble,9))\n}\ngetPUMSv3(2022,\"GASP\",\"HHL\")\n\n# A tibble: 9 × 4\n  V1    V2    V3    V4   \n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1 GASP  PWGTP HHL   SCHL \n2 3     6     0     24   \n3 3     23    0     24   \n4 3     23    0     24   \n5 3     80    0     24   \n6 3     16    0     24   \n7 3     107   0     24   \n8 3     10    0     24   \n9 3     22    0     24   \n\ngetPUMSv3(year=2022,numvarinput = \"GASP\")\n\n# A tibble: 9 × 4\n  V1    V2    V3    V4   \n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1 GASP  PWGTP SEX   SCHL \n2 3     6     2     24   \n3 3     23    2     24   \n4 3     23    1     24   \n5 3     80    1     24   \n6 3     16    1     24   \n7 3     107   1     24   \n8 3     10    2     24   \n9 3     22    1     24   \n\n\nWe could try all the requested categorical variables to see if works.\n\ngetPUMSv3(2022,\"GASP\",\"FER\")\n\n# A tibble: 9 × 4\n  V1    V2    V3    V4   \n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1 GASP  PWGTP FER   SCHL \n2 3     6     0     24   \n3 3     23    0     24   \n4 3     23    0     24   \n5 3     80    0     24   \n6 3     16    0     24   \n7 3     107   0     24   \n8 3     10    2     24   \n9 3     22    0     24   \n\ngetPUMSv3(2022,\"GASP\",\"HISPEED\")\n\n# A tibble: 9 × 4\n  V1    V2    V3      V4   \n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;\n1 GASP  PWGTP HISPEED SCHL \n2 3     6     0       24   \n3 3     23    0       24   \n4 3     23    0       24   \n5 3     80    0       24   \n6 3     16    0       24   \n7 3     107   0       24   \n8 3     10    0       24   \n9 3     22    0       24   \n\ngetPUMSv3(2022,\"GASP\",\"JWTRNS\")\n\n# A tibble: 9 × 4\n  V1    V2    V3     V4   \n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;\n1 GASP  PWGTP JWTRNS SCHL \n2 3     6     0      24   \n3 3     23    0      24   \n4 3     23    10     24   \n5 3     80    0      24   \n6 3     16    0      24   \n7 3     107   0      24   \n8 3     10    0      24   \n9 3     22    0      24   \n\ngetPUMSv3(2022,\"GASP\",\"SCH\")\n\n# A tibble: 9 × 4\n  V1    V2    V3    V4   \n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1 GASP  PWGTP SCH   SCHL \n2 3     6     1     24   \n3 3     23    1     24   \n4 3     23    1     24   \n5 3     80    1     24   \n6 3     16    1     24   \n7 3     107   1     24   \n8 3     10    1     24   \n9 3     22    1     24   \n\ngetPUMSv3(2022,\"GASP\",\"SCHL\")\n\n# A tibble: 9 × 4\n  V1    V2    V3    V4   \n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1 GASP  PWGTP SCHL  SCHL \n2 3     6     24    24   \n3 3     23    24    24   \n4 3     23    24    24   \n5 3     80    24    24   \n6 3     16    24    24   \n7 3     107   24    24   \n8 3     10    24    24   \n9 3     22    24    24   \n\n\nNow except for the variables not being categorical but character, all other requirements are there.\nUpdate: We modified the above function as follows. Changed column vector to ‘factor’ type for categorical variables. Function is getPUMSv3b\n\n# The function getPUMSv3 is modified as getPUMSv3b, as follows. Issues related to first row data and converting variable to categorical variable are addressed (SCHL = \"24\" was removed; did not see this requirement in the instructions. But then being added back - too long runtime)\ngetPUMSv3b &lt;- function (year = 2022, numvarinput = \"AGEP\", catvarinput = \"SEX\") {\n  base_url &lt;- paste0 (\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums\")\n  query_params &lt;- list(\n    get = paste0 (choosenum(numvarinput)[1],\",\",choosenum(numvarinput)[2],\",\",choosecat(catvarinput)),\n    SCHL = \"24\",\n    key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\")\n  \n  PUMScust &lt;- httr::GET(url = base_url, query = query_params)\n  PUMScust_parsed &lt;- fromJSON(rawToChar(PUMScust$content))\n  PUMScust_tibble &lt;- as_tibble (PUMScust_parsed)\n  colnames(PUMScust_tibble) &lt;- as.character(unlist(PUMScust_tibble[1,]))\n  PUMScust_tibble &lt;- PUMScust_tibble[-1, ]\n  PUMScust_tibble &lt;- mutate(PUMScust_tibble, PWGTP_n = as.numeric(PUMScust_tibble$PWGTP))\n  \n  # directly change the column vector to 'factor' type without adding a column to the dataset\n  PUMScust_tibble &lt;- PUMScust_tibble %&gt;% mutate(!!choosecat(catvarinput) := as.factor(.[[choosecat(catvarinput)]]))\n  PUMScust_tibble &lt;- PUMScust_tibble %&gt;% mutate(!!choosenum(numvarinput)[1] := as.numeric(.[[choosenum(numvarinput)[1]]]))\n  \n  return (head(PUMScust_tibble))\n  \n}\ngetPUMSv3b(2022,\"GASP\",\"HHL\")\n\n# A tibble: 6 × 5\n   GASP PWGTP HHL   SCHL  PWGTP_n\n  &lt;dbl&gt; &lt;chr&gt; &lt;fct&gt; &lt;chr&gt;   &lt;dbl&gt;\n1     3 6     0     24          6\n2     3 23    0     24         23\n3     3 23    0     24         23\n4     3 80    0     24         80\n5     3 16    0     24         16\n6     3 107   0     24        107"
  },
  {
    "objectID": "Project 1.html#make-a-function-to-specify-the-geographical-level",
    "href": "Project 1.html#make-a-function-to-specify-the-geographical-level",
    "title": "ST558-Project 1",
    "section": "Make a function to specify the geographical level",
    "text": "Make a function to specify the geographical level\nWe are interested in getting data with specific geographic levels and wanted to also specify the geographic items we are interested in (a specific region, district or state(s)). Checking the examples provided by the US census on the example URLs (https://api.census.gov/data/2022/acs/acs1/pums/examples.html):\nDefault call: https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24&key=YOUR_KEY_GOES_HERE\nTo get the region-specific data: https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&for=region:*&SCHL=24&key=YOUR_KEY_GOES_HERE.\nTo get the division-specific data: https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&for=division:*&SCHL=24&key=YOUR_KEY_GOES_HERE\nTo get the state-specific data: https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&for=state:*&SCHL=24&key=YOUR_KEY_GOES_HERE\nIt is easy to see the parameter here need to deal with is “for=XXX”, which is included in the argument “query” in the function GET(). Thus we could let the new function specify this part. But after playing with it for a while we figured out in the query_params, geographic option should be included in the “get=” argument instead of “for=” argument because in R for is designated for the loop.\n\ngetPUMSv4.0 &lt;- function (year = 2022, numvarinput = \"AGEP\", catvarinput = \"SEX\") {\n  base_url &lt;- paste0 (\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums\")\n  \n  query_params &lt;- list(\n    get = paste0 (choosenum(numvarinput)[1],\",\",choosenum(numvarinput)[2],\",\",choosecat(catvarinput),\",\",\"REGION\",\",\",\"ST\",\",\",\"DIVISION\"),\n    SCHL = \"24\",\n    key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\")\n  \n  PUMScust &lt;- httr::GET(url = base_url, query = query_params)\n  PUMScust_parsed &lt;- fromJSON(rawToChar(PUMScust$content))\n  PUMScust_tibble &lt;- as_tibble (PUMScust_parsed)\n  return (head (PUMScust_tibble))\n}\ngetPUMSv4.0(2022,\"GASP\",\"HHL\")\n\n# A tibble: 6 × 7\n  V1    V2    V3    V4     V5    V6       V7   \n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;\n1 GASP  PWGTP HHL   REGION ST    DIVISION SCHL \n2 3     6     0     2      17    3        24   \n3 3     23    0     4      06    9        24   \n4 3     23    0     1      42    2        24   \n5 3     80    0     4      49    8        24   \n6 3     16    0     2      18    3        24   \n\n\nWe updated the above code as follows. Function getPUMSv4.0b\n\n# WT: updates are mainly for address the data type converting\ngetPUMSv4.0b &lt;- function (year = 2022, numvarinput = \"AGEP\", catvarinput = \"SEX\") {\n  base_url &lt;- paste0 (\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums\")\n    query_params &lt;- list(\n    get = paste0 (choosenum(numvarinput)[1],\",\",choosenum(numvarinput)[2],\",\",choosecat(catvarinput),\",\",\"REGION\",\",\",\"ST\",\",\",\"DIVISION\"),\n    SCHL = \"24\",\n    key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\")\n  \n  PUMScust &lt;- httr::GET(url = base_url, query = query_params)\n  PUMScust_parsed &lt;- fromJSON(rawToChar(PUMScust$content))\n  PUMScust_tibble &lt;- as_tibble (PUMScust_parsed)\n  colnames(PUMScust_tibble) &lt;- as.character(unlist(PUMScust_tibble[1,]))\n  PUMScust_tibble &lt;- PUMScust_tibble[-1, ]\n  # this is to add a column and change the value type to numeric\n  PUMScust_tibble &lt;- mutate(PUMScust_tibble, PWGTP_n = as.numeric(PUMScust_tibble$PWGTP))\n  \n  # directly change the column vector to 'factor' type without adding a column to the dataset\n  PUMScust_tibble &lt;- PUMScust_tibble %&gt;% mutate(!!choosecat(catvarinput) := as.factor(.[[choosecat(catvarinput)]]))\n  PUMScust_tibble &lt;- PUMScust_tibble %&gt;% mutate(!!choosenum(numvarinput)[1] := as.numeric(.[[choosenum(numvarinput)[1]]]))\n  \n  return (head(PUMScust_tibble))\n  \n}\ngetPUMSv4.0b(2022,\"GASP\",\"HHL\")\n\n# A tibble: 6 × 8\n   GASP PWGTP HHL   REGION ST    DIVISION SCHL  PWGTP_n\n  &lt;dbl&gt; &lt;chr&gt; &lt;fct&gt; &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;   &lt;dbl&gt;\n1     3 6     0     2      17    3        24          6\n2     3 23    0     4      06    9        24         23\n3     3 23    0     1      42    2        24         23\n4     3 80    0     4      49    8        24         80\n5     3 16    0     2      18    3        24         16\n6     3 107   0     2      18    3        24        107\n\n\nFor the ease of exercising, I directly input the level of geography in the previous function. Now we want to build a function to let user select geographic level as well as specify the region, division or state. Let’s make a small function first.\n\nchoosegeolvl &lt;- function (geolvlinput) {\n  if (geolvlinput %in% c(\"REGION\", \"DIVISION\",\"ST\",\"all\"))\n  {geolvlvar &lt;- geolvlinput}\n  else {geolvlvar &lt;- \"Error\"}\n  return (geolvlvar)\n}\nchoosegeolvl (\"ST\")\n\n[1] \"ST\"\n\nchoosegeolvl(\"DIVISION\")\n\n[1] \"DIVISION\"\n\nchoosegeolvl (\"all\")\n\n[1] \"all\"\n\n\nNow that we have the function to specify geographic level we want to display, integrate in the main function. Note that the default was “of All”, which we interpret as all geographic levels.\n\ngetPUMSv4.1 &lt;- function (year = 2022, numvarinput = \"AGEP\", catvarinput = \"SEX\", geolvlinput) {\n  if (geolvlinput %in% c(\"REGION\", \"DIVISION\",\"ST\"))\n  {base_url &lt;- paste0 (\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums\")\n    query_params &lt;- list(\n    get = paste0 (choosenum(numvarinput)[1],\",\",choosenum(numvarinput)[2],\",\",choosecat(catvarinput),\",\",choosegeolvl(geolvlinput)),\n    SCHL = \"24\",\n    key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\")}\n  else if (geolvlinput == \"all\")\n  {base_url &lt;- paste0 (\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums\")\n    query_params &lt;- list(\n    get = paste0 (choosenum(numvarinput)[1],\",\",choosenum(numvarinput)[2],\",\",choosecat(catvarinput),\",\",\"REGION\",\",\",\"ST\",\",\",\"DIVISION\"),\n    SCHL = \"24\",\n    key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\")}\n  PUMScust &lt;- httr::GET(url = base_url, query = query_params)\n  PUMScust_parsed &lt;- fromJSON(rawToChar(PUMScust$content))\n  PUMScust_tibble &lt;- as_tibble (PUMScust_parsed)\n  return (head (PUMScust_tibble))\n}\ngetPUMSv4.1(2022,\"GASP\",\"HHL\",\"ST\")\n\n# A tibble: 6 × 5\n  V1    V2    V3    V4    V5   \n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1 GASP  PWGTP HHL   ST    SCHL \n2 280   30    3     06    24   \n3 3     55    5     06    24   \n4 3     62    1     39    24   \n5 3     98    1     42    24   \n6 40    33    3     48    24   \n\ngetPUMSv4.1(2022,\"GASP\",\"HHL\",\"all\")\n\n# A tibble: 6 × 7\n  V1    V2    V3    V4     V5    V6       V7   \n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;\n1 GASP  PWGTP HHL   REGION ST    DIVISION SCHL \n2 3     6     0     2      17    3        24   \n3 3     23    0     4      06    9        24   \n4 3     23    0     1      42    2        24   \n5 3     80    0     4      49    8        24   \n6 3     16    0     2      18    3        24   \n\n\nWT: Updated the above code as follows. Function “getPUMSv4.1b”\nSS: Changes including finalizing the tables and setting up a default output of all geographic level for this function.\n\n# WT: updated the code to \"getPUMSv4.1b\", but we did not see \"All\" in the variable list, only \"region\", \"ST\", ...\n# SS: Change the default input of geographic level into \"state\". Default = \"all\" is just asking to output all geolevel, but it is tricky to make this happen.\ngetPUMSv4.1b &lt;- function (year = 2022, numvarinput = \"AGEP\", catvarinput = \"SEX\", geolvlinput = \"all\") {\n  if (geolvlinput %in% c(\"REGION\", \"DIVISION\",\"ST\"))\n  {base_url &lt;- paste0 (\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums\")\n    query_params &lt;- list(\n    get = paste0 (choosenum(numvarinput)[1],\",\",choosenum(numvarinput)[2],\",\",choosecat(catvarinput),\",\",choosegeolvl(geolvlinput)),\n    SCHL = \"24\",\n    key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\")}\n  else if (geolvlinput == \"all\")\n  {base_url &lt;- paste0 (\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums\")\n    query_params &lt;- list(\n    get = paste0 (choosenum(numvarinput)[1],\",\",choosenum(numvarinput)[2],\",\",choosecat(catvarinput),\",\",\"REGION\",\",\",\"ST\",\",\",\"DIVISION\"),\n    SCHL = \"24\",\n    key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\")}\n  PUMScust &lt;- httr::GET(url = base_url, query = query_params)\n  PUMScust_parsed &lt;- fromJSON(rawToChar(PUMScust$content))\n  PUMScust_tibble &lt;- as_tibble (PUMScust_parsed)\n  colnames(PUMScust_tibble) &lt;- as.character(unlist(PUMScust_tibble[1,]))\n  PUMScust_tibble &lt;- PUMScust_tibble[-1, ]\n  # this is to add a column and change the value type to numeric\n  PUMScust_tibble &lt;- mutate(PUMScust_tibble, PWGTP_n = as.numeric(PUMScust_tibble$PWGTP))\n  \n  # directly change the column vector to 'factor' type without adding a column to the dataset\n  PUMScust_tibble &lt;- PUMScust_tibble %&gt;% mutate(!!choosecat(catvarinput) := as.factor(.[[choosecat(catvarinput)]]))\n  PUMScust_tibble &lt;- PUMScust_tibble %&gt;% mutate(!!choosenum(numvarinput)[1] := as.numeric(.[[choosenum(numvarinput)[1]]]))\n  \n  return (head(PUMScust_tibble))\n  \n}\ngetPUMSv4.1b(2022,\"GASP\",\"HHL\", \"DIVISION\")\n\n# A tibble: 6 × 6\n   GASP PWGTP HHL   DIVISION SCHL  PWGTP_n\n  &lt;dbl&gt; &lt;chr&gt; &lt;fct&gt; &lt;chr&gt;    &lt;chr&gt;   &lt;dbl&gt;\n1     3 6     0     3        24          6\n2     3 23    0     9        24         23\n3     3 23    0     2        24         23\n4     3 80    0     8        24         80\n5     3 16    0     3        24         16\n6     3 107   0     3        24        107\n\ngetPUMSv4.1b(2022,\"GASP\",\"HHL\", \"all\")\n\n# A tibble: 6 × 8\n   GASP PWGTP HHL   REGION ST    DIVISION SCHL  PWGTP_n\n  &lt;dbl&gt; &lt;chr&gt; &lt;fct&gt; &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;   &lt;dbl&gt;\n1     3 6     0     2      17    3        24          6\n2     3 23    0     4      06    9        24         23\n3     3 23    0     1      42    2        24         23\n4     3 80    0     4      49    8        24         80\n5     3 16    0     2      18    3        24         16\n6     3 107   0     2      18    3        24        107\n\n\nNow let’s enable an option to allow user to subset the data based on geographic information, and it must be on API. Considering the argument of query is essentially a list, which specifies “SCHL =”24”, we could try specify here as well.\n\ngetPUMSv4.2 &lt;- function (year = 2022, numvarinput = \"AGEP\", catvarinput = \"SEX\", geolvlinput = \"all\", geospctinput) {\n  if (geolvlinput == \"REGION\")\n  {base_url &lt;- paste0 (\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums\")\n    query_params &lt;- list(\n    get = paste0 (choosenum(numvarinput)[1],\",\",choosenum(numvarinput)[2],\",\",choosecat(catvarinput),\",\",choosegeolvl(geolvlinput)),\n    SCHL = \"24\",\n    REGION = as.character (geospctinput),\n    key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\")}\n  else if (geolvlinput == \"DIVISION\")\n  {base_url &lt;- paste0 (\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums\")\n    query_params &lt;- list(\n    get = paste0 (choosenum(numvarinput)[1],\",\",choosenum(numvarinput)[2],\",\",choosecat(catvarinput),\",\",choosegeolvl(geolvlinput)),\n    SCHL = \"24\",\n    DIVISION = as.character (geospctinput),\n    key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\")}\n  else if (geolvlinput == \"ST\")\n  {base_url &lt;- paste0 (\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums\")\n    query_params &lt;- list(\n    get = paste0 (choosenum(numvarinput)[1],\",\",choosenum(numvarinput)[2],\",\",choosecat(catvarinput),\",\",choosegeolvl(geolvlinput)),\n    SCHL = \"24\",\n    ST = as.character (geospctinput),\n    key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\")}\n  else if (geolvlinput == \"all\")\n  {base_url &lt;- paste0 (\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums\")\n    query_params &lt;- list(\n    get = paste0 (choosenum(numvarinput)[1],\",\",choosenum(numvarinput)[2],\",\",choosecat(catvarinput),\",\",\"REGION\",\",\",\"ST\",\",\",\"DIVISION\"),\n    SCHL = \"24\",\n    key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\")}\n  base_url &lt;- paste0 (\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums\")\n  query_params &lt;- list(\n    get = paste0 (choosenum(numvarinput)[1],\",\",choosenum(numvarinput)[2],\",\",choosecat(catvarinput),\",\",choosegeolvl(geolvlinput)),\n    ST = \"09\",\n    SCHL = \"23\",\n    key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\")\n  \n  PUMScust &lt;- httr::GET(url = base_url, query = query_params)\n  PUMScust_parsed &lt;- fromJSON(rawToChar(PUMScust$content))\n  PUMScust_tibble &lt;- as_tibble (PUMScust_parsed)\n  colnames(PUMScust_tibble) &lt;- as.character(unlist(PUMScust_tibble[1,]))\n  PUMScust_tibble &lt;- PUMScust_tibble[-1, ]\n  # this is to add a column and change the value type to numeric\n  PUMScust_tibble &lt;- mutate(PUMScust_tibble, PWGTP_n = as.numeric(PUMScust_tibble$PWGTP))\n  \n  # directly change the column vector to 'factor' type without adding a column to the dataset\n  PUMScust_tibble &lt;- PUMScust_tibble %&gt;% mutate(!!choosecat(catvarinput) := as.factor(.[[choosecat(catvarinput)]]))\n  PUMScust_tibble &lt;- PUMScust_tibble %&gt;% mutate(!!choosenum(numvarinput)[1] := as.numeric(.[[choosenum(numvarinput)[1]]]))\n  return (head (PUMScust_tibble))\n}\ngetPUMSv4.2(2022,\"GASP\",\"HHL\",\"state\",\"09\")\n\nIt throws out an error. Looks like geographic-related variables could not be subset in the same way as other variables. But how to solve the ‘for’ problem? We figured out later a backtick (`) should be used to avoid confusion.\n\n# WT: updated the above function as follows.\n# SS: 1. There is a special thing about the level \"ST\". as a variable it is called \"ST\", but in the \"for\" call it is called \"state\". It was a pity they were not the same.\n# SS: 2. Modified the tibble coding part. Use |&gt; instead of %&gt;% and adding more string to keep the coding compact. Dropped the SCHL function that is previously encoded to speed up\n\ngetPUMSv4.3 &lt;- function (year = 2022, \n                         numvarinput = \"AGEP\", \n                         catvarinput = \"SEX\", \n                         geolvlinput = \"all\", \n                         geospecinput) {\n\n  base_url &lt;- paste0(\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums\")\n  \n    #If you requested to see such geographic level data, then need to get the geo data for the corresponding levels and also you could search specific code based on the requested geographic level.\n  if (geolvlinput %in% c(\"REGION\", \"DIVISION\"))\n  {\n    query_params &lt;- list(\n    get = paste0 (choosenum(numvarinput)[1],\",\",choosenum(numvarinput)[2],\",\",choosecat(catvarinput),\",\",choosegeolvl(geolvlinput)),\n    `for` = paste0 (geolvlinput,\":\",geospecinput),\n    SCHL = \"24\",\n    key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\")\n  }\n  else if (geolvlinput == \"ST\")\n  {\n    query_params &lt;- list(\n    get = paste0 (choosenum(numvarinput)[1],\",\",choosenum(numvarinput)[2],\",\",choosecat(catvarinput),\",\",\"ST\"),\n    `for` = paste0 (\"state\",\":\",geospecinput),\n    SCHL = \"24\",\n    key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\")\n  }\n  else if (geolvlinput == \"all\")\n  {\n    query_params &lt;- list(\n    get = paste0 (choosenum(numvarinput)[1],\",\",choosenum(numvarinput)[2],\",\",choosecat(catvarinput),\",\",\"REGION\",\",\",\"ST\",\",\",\"DIVISION\"),\n    SCHL = \"24\",\n    key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\")}\n  PUMScust &lt;- httr::GET(url = base_url, query = query_params)\n  PUMScust_parsed &lt;- fromJSON(rawToChar(PUMScust$content))\n  PUMScust_tibble &lt;- as_tibble (PUMScust_parsed)\n  colnames(PUMScust_tibble) &lt;- as.character(unlist(PUMScust_tibble[1,]))\n  PUMScust_tibble &lt;- PUMScust_tibble[-1, ]\n  PUMScust_tibble &lt;- PUMScust_tibble |&gt; mutate(PWGTP := as.numeric(PUMScust_tibble$PWGTP))\n  PUMScust_tibble &lt;- PUMScust_tibble %&gt;% mutate(!!choosecat(catvarinput) := as.factor(.[[choosecat(catvarinput)]]))\n  PUMScust_tibble &lt;- PUMScust_tibble %&gt;% mutate(!!choosenum(numvarinput)[1] := as.numeric(.[[choosenum(numvarinput)[1]]])) |&gt; select (1:4)\n  return (head (PUMScust_tibble))\n}\ngetPUMSv4.3(2022,\"GASP\",\"HHL\",\"ST\",\"37\")\n\n# A tibble: 6 × 4\n   GASP PWGTP HHL   ST   \n  &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt;\n1    40    88 1     37   \n2    80   109 4     37   \n3    30    42 1     37   \n4     3   116 1     37   \n5     3   149 1     37   \n6     3   224 4     37   \n\ngetPUMSv4.3(2022,\"GASP\",\"HHL\",\"DIVISION\",\"5\")\n\n# A tibble: 6 × 4\n   GASP PWGTP HHL   DIVISION\n  &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt;   \n1     3    10 0     5       \n2     3   138 0     5       \n3     3    42 0     5       \n4     3    27 0     5       \n5     3     9 0     5       \n6     3    74 0     5       \n\ngetPUMSv4.3(2022,\"GASP\",\"HHL\",\"REGION\",\"1\")\n\n# A tibble: 6 × 4\n   GASP PWGTP HHL   REGION\n  &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; \n1     3    23 0     1     \n2     3    20 0     1     \n3     3    24 0     1     \n4     3    98 0     1     \n5     3   101 0     1     \n6     3   114 0     1"
  },
  {
    "objectID": "Project 1.html#make-a-function-to-see-multiple-years-of-survey-data",
    "href": "Project 1.html#make-a-function-to-see-multiple-years-of-survey-data",
    "title": "ST558-Project 1",
    "section": "Make a function to see multiple years of survey data",
    "text": "Make a function to see multiple years of survey data\nNow we modify the function so that we can pull multiple years of survey data\n\n# Function: getPUMSv4.4\ngetPUMSv4.4 &lt;- function (years = c(2022), numvarinput = \"AGEP\", catvarinput = \"SEX\", geolvlinput, geospecinput, filter_value = NULL, filter_column = NULL) {\n  \n  # create an empty list\n  multiple_years &lt;- list()\n  \n  for (year in years) {\n    if (geolvlinput %in% c(\"REGION\", \"DIVISION\"))\n      {base_url &lt;- paste0 (\"https://api.census.gov/data/\",as.character(year), \"/acs/acs1/pums\")\n      query_params &lt;- list(\n        get = paste0 (choosenum(numvarinput)[1],\",\",choosenum(numvarinput)[2],\",\",choosecat(catvarinput),\",\",choosegeolvl(geolvlinput)),\n        `for` = paste0 (geolvlinput,\":\",geospecinput),\n        SCHL = \"24\",\n        key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\")\n  }\n  else if (geolvlinput == \"ST\")\n  {base_url &lt;- paste0 (\"https://api.census.gov/data/\",as.character(year), \"/acs/acs1/pums\")\n    query_params &lt;- list(\n    get = paste0 (choosenum(numvarinput)[1],\",\",choosenum(numvarinput)[2],\",\",choosecat(catvarinput),\",\",\"ST\"),\n    `for` = paste0 (\"state\",\":\",geospecinput),\n    SCHL = \"24\",\n    key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\")\n  }\n  else if (geolvlinput == \"all\")\n  {base_url &lt;- paste0 (\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums\")\n    query_params &lt;- list(\n    get = paste0 (choosenum(numvarinput)[1],\",\",choosenum(numvarinput)[2],\",\",choosecat(catvarinput),\",\",\"REGION\",\",\",\"ST\",\",\",\"DIVISION\"),\n    SCHL = \"24\",\n    key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\")}\n    \n  # optional filtering\n  if (!is.null(filter_value) & !is.null(filter_column)) {\n    query_params[[filter_column]] &lt;- filter_value\n  }\n  \n  PUMScust &lt;- httr::GET(url = base_url, query = query_params)\n  PUMScust_parsed &lt;- fromJSON(rawToChar(PUMScust$content))\n  PUMScust_tibble &lt;- as_tibble (PUMScust_parsed)\n  colnames(PUMScust_tibble) &lt;- as.character(unlist(PUMScust_tibble[1,]))\n  PUMScust_tibble &lt;- PUMScust_tibble[-1, ]\n  PUMScust_tibble &lt;- PUMScust_tibble |&gt; mutate(PWGTP := as.numeric(PUMScust_tibble$PWGTP))\n  PUMScust_tibble &lt;- PUMScust_tibble %&gt;% mutate(!!choosecat(catvarinput) := as.factor(.[[choosecat(catvarinput)]]))\n  PUMScust_tibble &lt;- PUMScust_tibble %&gt;% mutate(!!choosenum(numvarinput)[1] := as.numeric(.[[choosenum(numvarinput)[1]]])) |&gt; select (1:4) |&gt; mutate (YEAR = as.character (year))\n  #SS: Added year as a variable so that we know which year the data comes from\n    \n  multiple_years[[as.character(year)]] &lt;- PUMScust_tibble\n  }  \n    allyeardata &lt;- bind_rows(multiple_years)\n    # we remove the 'head', so that the function returns a complete tibble dataset\n  return(allyeardata)\n}\n# following call works (takes long time)\ngetPUMSv4.4(c(2021,2022),\"GASP\",\"HHL\",\"ST\",\"37\",filter_value=\"24\", filter_column = \"SCHL\" )\n\n# A tibble: 2,752 × 5\n    GASP PWGTP HHL   ST    YEAR \n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; &lt;chr&gt;\n 1     3    34 0     37    2021 \n 2     3    73 0     37    2021 \n 3     3    79 0     37    2021 \n 4     3    48 0     37    2021 \n 5    30    83 1     37    2021 \n 6    80    71 1     37    2021 \n 7    20    89 1     37    2021 \n 8    20    79 1     37    2021 \n 9    40    54 1     37    2021 \n10    70   352 4     37    2021 \n# ℹ 2,742 more rows"
  },
  {
    "objectID": "Project 1.html#first-steps",
    "href": "Project 1.html#first-steps",
    "title": "ST558-Project 1",
    "section": "First steps",
    "text": "First steps\nIn the follwoing function “getPUMSsum”, we get the class ‘census’ assigned to tibble at the end, to get things ready for the next function ‘summary.census’. Tied up a couple of loose ends. We specify that state = “09” in the API query. According to the updated instructions, our group only works the subset data where ST = ‘09’ (Connecticut). We also included a column of ‘year’. Finally, we convert JWAP or JWDP to the minutes since midnight (column names are JWAP_since_midnight, JWDP_since_midnight, respective) with reasonable accuracy.\n\n# This function is updated to include 'census' class assigned to the tibble  \ngetPUMSsum &lt;- function (years = c(2022), numvarinput = \"AGEP\", catvarinput = \"SEX\", geolvlinput, filter_value = NULL, filter_column = NULL) {\n  \n  # create an empty list\n  multiple_years &lt;- list()\n    for (year in years) {\n    \n    base_url &lt;- paste0 (\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums\")\n    ST = \"09\"\n    query_params &lt;- list(\n    get = paste0 (choosenum(numvarinput)[1],\",\",choosenum(numvarinput)[2],\",\",choosecat(catvarinput),\",\",choosegeolvl(geolvlinput)),\n    `for` = \"state:09\",  # add the state filter to the query, only pull ST = \"09\" data, Connecticut\n    key = \"41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c\"    )\n  # optional filtering\n  if (!is.null(filter_value) & !is.null(filter_column)) {\n    query_params[[filter_column]] &lt;- filter_value\n  }\n  PUMScust &lt;- httr::GET(url = base_url, query = query_params)\n  PUMScust_parsed &lt;- fromJSON(rawToChar(PUMScust$content))\n  PUMScust_tibble &lt;- as_tibble (PUMScust_parsed)\n  colnames(PUMScust_tibble) &lt;- as.character(unlist(PUMScust_tibble[1,]))\n  PUMScust_tibble &lt;- PUMScust_tibble[-1, ]\n  # this is to add a column and change the value type to numeric\n  PUMScust_tibble &lt;- PUMScust_tibble |&gt; mutate(PWGTP := as.numeric(PUMScust_tibble$PWGTP))\n  PUMScust_tibble &lt;- PUMScust_tibble %&gt;% mutate(!!choosecat(catvarinput) := as.factor(.[[choosecat(catvarinput)]]))\n  PUMScust_tibble &lt;- PUMScust_tibble %&gt;% mutate(!!choosenum(numvarinput)[1] := as.numeric(.[[choosenum(numvarinput)[1]]])) |&gt; select (1:4) |&gt; mutate (YEAR = as.character (year))\n  multiple_years[[as.character(year)]] &lt;- PUMScust_tibble\n  }  \n  allyeardata &lt;- bind_rows(multiple_years)\n  current_classes &lt;- class(allyeardata)\n  class(allyeardata) &lt;- c(\"census\", current_classes)\n  \n  # to convert the JWDP and JWAP to the minutes since midnight, roughly\n  if(\"JWAP\" %in% colnames(allyeardata)){\n    allyeardata &lt;- allyeardata %&gt;% mutate(JWAP_since_midnight = ifelse(JWAP != 0, 2+(JWAP-1)*5, 0))\n  }\n  if(\"JWDP\" %in% colnames(allyeardata)){\n    allyeardata &lt;- allyeardata %&gt;% mutate(JWDP_since_midnight = ifelse(JWDP != 0, 15+9*(JWDP-1), 0))\n  }\n    # we remove the 'head', so that the function returns a complete tibble dataset\n  return(allyeardata)\n}\n# following call works\ngetPUMSsum(c(2021,2022),\"GASP\",\"HHL\",\"ST\",filter_value=\"24\", filter_column = \"SCHL\" )\n\n# A tibble: 1,245 × 5\n    GASP PWGTP HHL   ST    YEAR \n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; &lt;chr&gt;\n 1     3    52 0     09    2021 \n 2     3     3 0     09    2021 \n 3     3     5 0     09    2021 \n 4     3    19 0     09    2021 \n 5     3     3 0     09    2021 \n 6     3    10 0     09    2021 \n 7     3    91 0     09    2021 \n 8     3     4 0     09    2021 \n 9   180    66 5     09    2021 \n10     3   381 1     09    2021 \n# ℹ 1,235 more rows\n\ngetPUMSsum(c(2021,2022),\"JWAP\",\"HHL\",\"ST\",filter_value=\"24\", filter_column = \"SCHL\" )\n\n# A tibble: 1,245 × 6\n    JWAP PWGTP HHL   ST    YEAR  JWAP_since_midnight\n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; &lt;chr&gt;               &lt;dbl&gt;\n 1     0    52 0     09    2021                    0\n 2     0     3 0     09    2021                    0\n 3     0     5 0     09    2021                    0\n 4     0    19 0     09    2021                    0\n 5     0     3 0     09    2021                    0\n 6     0    10 0     09    2021                    0\n 7     0    91 0     09    2021                    0\n 8     0     4 0     09    2021                    0\n 9    92    66 5     09    2021                  457\n10    96   381 1     09    2021                  477\n# ℹ 1,235 more rows\n\ngetPUMSsum(c(2021,2022),\"JWDP\",\"HHL\",\"ST\",filter_value=\"24\", filter_column = \"SCHL\" )\n\n# A tibble: 1,245 × 6\n    JWDP PWGTP HHL   ST    YEAR  JWDP_since_midnight\n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; &lt;chr&gt;               &lt;dbl&gt;\n 1    31   193 2     09    2021                  285\n 2     0    51 3     09    2021                    0\n 3    61   108 3     09    2021                  555\n 4     0    82 3     09    2021                    0\n 5    61    54 3     09    2021                  555\n 6    19    60 1     09    2021                  177\n 7     0    54 1     09    2021                    0\n 8    79    52 1     09    2021                  717\n 9     0    91 1     09    2021                    0\n10     0    58 1     09    2021                    0\n# ℹ 1,235 more rows\n\ngetPUMSsum(c(2021,2022),\"JWMNP\",\"HHL\",\"ST\",filter_value=\"24\", filter_column = \"SCHL\" )\n\n# A tibble: 1,245 × 5\n   JWMNP PWGTP HHL   ST    YEAR \n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; &lt;chr&gt;\n 1     0    52 0     09    2021 \n 2     0     3 0     09    2021 \n 3     0     5 0     09    2021 \n 4     0    19 0     09    2021 \n 5     0     3 0     09    2021 \n 6     0    10 0     09    2021 \n 7     0    91 0     09    2021 \n 8     0     4 0     09    2021 \n 9    30    66 5     09    2021 \n10    70   381 1     09    2021 \n# ℹ 1,235 more rows\n\n# get the data and give it a name, which will be the first argument in the Function \"summary.census\"\nPUMS_tibble_census &lt;- getPUMSsum(c(2021,2022),\"GASP\",\"HHL\",\"ST\",filter_value=\"24\", filter_column = \"SCHL\" )\nPUMS_tibble_census1 &lt;- getPUMSsum(c(2021,2022),\"GRPIP\",\"HHL\",\"ST\",filter_value=\"24\", filter_column = \"SCHL\" )\nPUMS_tibble_census2 &lt;- getPUMSsum(c(2021,2022),\"JWAP\",\"HHL\",\"ST\",filter_value=\"24\", filter_column = \"SCHL\" )\nPUMS_tibble_census2\n\n# A tibble: 1,245 × 6\n    JWAP PWGTP HHL   ST    YEAR  JWAP_since_midnight\n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; &lt;chr&gt;               &lt;dbl&gt;\n 1    88   224 3     09    2021                  437\n 2     0    34 1     09    2021                    0\n 3     0    52 1     09    2021                    0\n 4     0    64 1     09    2021                    0\n 5   109   157 3     09    2021                  542\n 6     0    55 1     09    2021                    0\n 7     0    33 1     09    2021                    0\n 8   104    68 1     09    2021                  517\n 9     0    54 1     09    2021                    0\n10     0   111 3     09    2021                    0\n# ℹ 1,235 more rows\n\n\nWe developed a function “summary.census” below that produces means and standard deviations for numeric variables and counts for categorical variables SS: To reflect changes in eleminating unecessary columns, a few changes were made.\n\n# This function will use the output of getPUMSsum function as one of the argument, and summarize weighted mean, std. dev, and the count\nsummary.census &lt;- function(tibble_data, num_vars=NULL, cat_vars=NULL) {\n  # if numeric variable, then put it in a vector num_vars. We leave \"PWGTP\" out, it's the weighting info used in summary\n\n  if(is.null(num_vars)){\n    num_vars &lt;- names(tibble_data)[sapply(tibble_data, is.numeric) & names(tibble_data) != \"PWGTP\" ]\n  }\n  # if categorical variable, then put it in a vector cat_vars\n  if(is.null(cat_vars)){\n    cat_vars &lt;- names(tibble_data)[sapply(tibble_data, is.factor)]\n  }\n    result_list &lt;- list()\n  weight_vector &lt;- tibble_data$PWGTP\n  \n  for (num_var in num_vars){\n    numeric_vector &lt;- tibble_data[[num_var]]\n  \n  # calculate mean and standard deviation for numeric variables. If it is JWAP, JWDP, JWMNP, then we only include nonzero values because the individual does not travel to work (WFH, etc) if it is zero.  \n  sample_mean &lt;- if(num_var %in% c(\"JWAP\", \"JWDP\", \"JWMNP\")){\n      valid_indices &lt;- numeric_vector != 0\n      sum(numeric_vector[valid_indices] * weight_vector[valid_indices]) / sum(weight_vector[valid_indices])\n    }\n    else {\n       sum(numeric_vector*weight_vector)/sum(weight_vector)\n    }\n\n  sample_stddev &lt;- if(num_var %in% c(\"JWAP\", \"JWDP\", \"JWMNP\")){\n      valid_indices &lt;- numeric_vector != 0\n      sqrt(sum(numeric_vector[valid_indices]^2*weight_vector[valid_indices])/sum(weight_vector[valid_indices])-sample_mean^2)\n    }\n    else {\n       sqrt(sum(numeric_vector^2*weight_vector)/sum(weight_vector)-sample_mean^2)\n    }\n\n  # calculate sample mean for numeric variable\n  #  sample_mean &lt;- sum(numeric_vector*weight_vector)/sum(weight_vector)\n  # calculate sample std dev for numeric variable\n  #  sample_stddev &lt;- sqrt(sum(numeric_vector^2*weight_vector)/sum(weight_vector)-sample_mean^2)\n  \n  # return the values as a named list\n  result_list[[paste0(num_var, \"_mean\")]] &lt;- sample_mean\n  result_list[[paste0(num_var, \"_sd\")]] &lt;- sample_stddev\n  }\n  \n  for (cat_var in cat_vars){\n    cat_table &lt;- table(tibble_data[[cat_var]])\n    result_list[[paste0(cat_var, \"_counts\")]] &lt;- cat_table\n  }\n  return(result_list)\n}\n\nsummary_stat &lt;- summary.census(PUMS_tibble_census)\nsummary_stat\n\n$GASP_mean\n[1] 90.97883\n\n$GASP_sd\n[1] 187.7397\n\n$HHL_counts\n\n  0   1   2   3   4   5 \n 14 819  51 192 145  24 \n\nsummary_stat2 &lt;- summary.census(PUMS_tibble_census2)\nsummary_stat2\n\n$JWAP_mean\n[1] 100.4298\n\n$JWAP_sd\n[1] 24.82448\n\n$JWAP_since_midnight_mean\n[1] 293.1109\n\n$JWAP_since_midnight_sd\n[1] 263.5128\n\n$HHL_counts\n\n  0   1   2   3   4   5 \n 14 819  51 192 145  24"
  },
  {
    "objectID": "Project 1.html#plot-function",
    "href": "Project 1.html#plot-function",
    "title": "ST558-Project 1",
    "section": "Plot function",
    "text": "Plot function\nNext, We create a generic plot() function for a census class tibble\n\n# This code chunk creates a generic plot() function for a census class tibble, with three arguments. \nlibrary(ggplot2)\n\nWarning: package 'ggplot2' was built under R version 4.3.3\n\nplot.census &lt;- function(tibble_data, cat_var, num_var){\n  plot &lt;- ggplot((tibble_data), \n                 aes(x = get(cat_var), \n                     y = get(num_var), \n                     weight = PWGTP)) +\n                geom_boxplot()+\n    labs(title = paste(\"Plot of\", num_var, \"by\", cat_var)) +\n    xlab(cat_var) + \n    ylab(num_var)\n  print(plot)\n}\n\n# call the function and return a plot\nplot.census(PUMS_tibble_census, \"HHL\", \"GASP\")\n\nWarning in rq.fit.br(wx, wy, tau = tau, ...): Solution may be nonunique\n\n\n\n\nplot.census(PUMS_tibble_census1, \"HHL\", \"GRPIP\")\n\n\n\nplot.census(PUMS_tibble_census2, \"HHL\", \"JWAP_since_midnight\")"
  },
  {
    "objectID": "Project 1.html#interesting-topics-to-investigate-using-the-census-data-and-the-api-and-summary-functions.",
    "href": "Project 1.html#interesting-topics-to-investigate-using-the-census-data-and-the-api-and-summary-functions.",
    "title": "ST558-Project 1",
    "section": "Interesting topics to investigate using the census data and the API and summary functions.",
    "text": "Interesting topics to investigate using the census data and the API and summary functions.\nTopic - How does gross rent as a % of household income vary among different language speaking families? (We were more interested in finding income distribution among different attributes. However, the GRPIP variable seems not working in API function. Will revisit) Update: Works like a charm!\n\nPUMS_tibble_census &lt;- getPUMSsum(c(2021,2022),\"GRPIP\",\"HHL\",\"ST\",filter_value=\"24\", filter_column = \"SCHL\" )\nPUMS_tibble_census\n\n# A tibble: 1,245 × 5\n   GRPIP PWGTP HHL   ST    YEAR \n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; &lt;chr&gt;\n 1     0   193 2     09    2021 \n 2     0    51 3     09    2021 \n 3     0   108 3     09    2021 \n 4     0    82 3     09    2021 \n 5    29    54 3     09    2021 \n 6     0    60 1     09    2021 \n 7    25    54 1     09    2021 \n 8    22    52 1     09    2021 \n 9     0    91 1     09    2021 \n10    20    58 1     09    2021 \n# ℹ 1,235 more rows\n\n# obtain the summary statistics\nsummary_stat &lt;- summary.census(PUMS_tibble_census)\nsummary_stat\n\n$GRPIP_mean\n[1] 4.989386\n\n$GRPIP_sd\n[1] 14.13104\n\n$HHL_counts\n\n  0   1   2   3   4   5 \n 14 819  51 192 145  24 \n\n\n\n# plot\nplot.census(PUMS_tibble_census, \"HHL\", \"GRPIP\")"
  },
  {
    "objectID": "Project 1.html#final-remarks.",
    "href": "Project 1.html#final-remarks.",
    "title": "ST558-Project 1",
    "section": "Final remarks.",
    "text": "Final remarks.\nAfter several trial and error in each step explained in the instructions, we were able to finalize a function “getPUMSsum” that does what are required in the project. To verify the functionality, the function was called with various combinations of options, and we were able to obtain the summary statistics and the plot from the data retrieved.\n\nPUMS_tibble_census &lt;- getPUMSsum(c(2019, 2021,2022),\"GASP\",\"HHL\",\"ST\",filter_value=\"24\", filter_column = \"SCHL\" )\nPUMS_tibble_census &lt;- getPUMSsum(c(2019, 2021,2022),\"GRPIP\",\"SCH\",\"ST\",filter_value=\"24\", filter_column = \"SCHL\" )\nPUMS_tibble_census &lt;- getPUMSsum(c(2019, 2021,2022),\"JWAP\",\"JWTRNS\",\"ST\",filter_value=\"24\", filter_column = \"SCHL\" )\nsummary_stat &lt;- summary.census(PUMS_tibble_census)\nsummary_stat2 &lt;- summary.census(PUMS_tibble_census2)"
  }
]