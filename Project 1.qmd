---
title: "ST558-Project 1"
author: "Siyuan Su"
format: html
editor: visual
---

# Introduction

Census data is of a great interest of statisticians, but it could be challenging to get data from API. Let's first try the example call:

```{r}
library (dplyr)
library (jsonlite)
```

```{r}
base_url_trial <- "https://api.census.gov/data/2022/acs/acs1/pums"
query_params <- list(
  get = "SEX,PWGTP,MAR",   # Fields to retrieve
  SCHL = "24",             # Filter
  key = "41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c"  # API key
)
PUMS_trial <- httr::GET(url = base_url, query = query_params)
PUMS_trial_parsed <- fromJSON(rawToChar(PUMS_trial$content))
str (PUMS_trial_parsed)
```

Then we turn the PUMS_trial into a tibble

```{r}
PUMS_trial_tibble <- as_tibble (PUMS_trial_parsed)
head (PUMS_trial_tibble)
```

Wow, that was successful. So the key was to put the conditions in the query argument in the function GET().

# Data Processing

Now we are going to set out to construct a new function called getPUMS. https://api.census.gov/data/2022/acs/acs1/pums/variables.html Showed all the variable in the data set, which has 525 variables. It would be very hard to get all the variables, even just to a few lines of data. So we have to make clear of what variables to get in the very beginning of writing and adjusting the functions. Let's first go with the original variables in the test sample and deal with the year issue.

## Select functions enabling the selection of year.

We wanted to customize a function that enable custom-selection of Year of survey with default at 2022. That must have something to do with the URL we are inquiring. Let's stick to the variable settings in the trial and play with the year of survey first.

```{r}
getPUMS <- function (year = 2022) {
  base_url <- paste0 ("https://api.census.gov/data/", as.character(year), "/acs/acs1/pums")
  
  query_params <- list(
  get = "SEX,PWGTP,MAR,AGEP",   
  SCHL = "24",             
  key = "41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c") 
  
  PUMScust <- httr::GET(url = base_url, query = query_params)
  PUMScust_parsed <- fromJSON(rawToChar(PUMScust$content))
  PUMScust_tibble <- as_tibble (PUMScust_parsed)
  return (head (PUMScust_tibble))
}
getPUMS (2022)
```

It looks like worked. Let's see whether it worked on other years.

```{r}
getPUMS (2021)
getPUMS (2019)
```

They all worked. I also noticed that there is if year=2020, will return an error. It turned out the ACS 1-Year PUMS data for the year 2020 was not included in the default path because of smaller-than-previous sample issue.

## Make a function that specifies the numeric values to be returned.

Next we wanted to make a function that solely tells which numeric values to be returned. Default was AGEP and PWGTP, with several options being available.

```{r}
choosenum <- function (numvarinput) {
  
  numvar <- ifelse (numvarinput %in% c("AGEP", "GASP", "GRPIP", "JWAP", "JWMNP"),
             c(numvarinput, "PWGTP"), 
             "error: numeric variable must match with exisiting numeric variable names")
  return (numvar)
  
}
choosenum ("AGEP")
```

It is weird no matter what I input, the choosenum function always returns an one-element vector. It turns out this is the setting of ifelse syntax. Try if-else sentence instead.

```{r}
choosenum <- function (numvarinput) {
  if (numvarinput %in% c("AGEP", "GASP", "GRPIP", "JWAP", "JWMNP"))
  {numvar <- c (numvarinput, "PWGTP")}
  else {numvar <- "Error"}
  return (numvar)
}
choosenum ("GASP")
```

It retuns a string of two characters and takes both my input and another variant PWGTP. Now try "attaching" the new function with our main function getPUMS ()

```{r}
getPUMSv2 <- function (year = 2022, numvarinput = "AGEP") {
  base_url <- paste0 ("https://api.census.gov/data/", as.character(year), "/acs/acs1/pums")
  
  query_params <- list(
  get = paste0 (choosenum(numvarinput)[1],",",choosenum(numvarinput)[2]),
                SCHL = "24",
                key = "41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c") 
  
  PUMScust <- httr::GET(url = base_url, query = query_params)
  PUMScust_parsed <- fromJSON(rawToChar(PUMScust$content))
  PUMScust_tibble <- as_tibble (PUMScust_parsed)
  return (head (PUMScust_tibble))
}
getPUMSv2(2022, "GASP")
```

What happens if I don't choose any numeric values?

```{r}
getPUMSv2(2022)
```

This is cool. This way ensures the numeric input must have a value. Now if you look closely at the objects returned by the getPUMSv2 function, these variables are all character variables. Make them numeric now!

```{r}
getPUMSv2.1 <- function (year = 2022, numvarinput) {  
  base_url <- paste0 ("https://api.census.gov/data/", as.character(year), "/acs/acs1/pums")
  
  query_params <- list(
  get = paste0 (choosenum(numvarinput)[1],",",choosenum(numvarinput)[2]),
                SCHL = "24",
                key = "41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c") 
  
  PUMScust <- httr::GET(url = base_url, query = query_params)
  PUMScust_parsed <- fromJSON(rawToChar(PUMScust$content))
  PUMScust_tibble <- as_tibble (PUMScust_parsed)
  PUMScust_tibble <- mutate (PUMScust_tibble, PWGTP_n = as.numeric(PUMScust_tibble$PWGTP))
    return (head (PUMScust_tibble))
}
getPUMSv2.1(2022, "GASP")
```

Seemed to be very hard. Let's put it here for now and move on to the next topic.

## Make a function that specifies the categorical variables to be returned.

Similarly for catogorical variables, we wanted to make a function that solely tells which character values to be returned. Default was SEX, with several options being available.

```{r}
choosecat <- function (catvarinput) {
  if (catvarinput %in% c("FER", "HHL", "HISPEED", "JWTRNS", "SCH", "SCHL", "SEX"))
  {catvar <- catvarinput}
  else {catvar <- "Error"}
  return (catvar)
}
choosecat ("FER")
```

Now let's concatenate this sub function into the original function

```{r}
getPUMSv3 <- function (year = 2022, numvarinput = "AGEP", catvarinput = "SEX") {
  base_url <- paste0 ("https://api.census.gov/data/", as.character(year), "/acs/acs1/pums")
  
  query_params <- list(
    get = paste0 (choosenum(numvarinput)[1],",",choosenum(numvarinput)[2],",",choosecat(catvarinput)),
    SCHL = "24",
    key = "41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c")
  
  PUMScust <- httr::GET(url = base_url, query = query_params)
  PUMScust_parsed <- fromJSON(rawToChar(PUMScust$content))
  PUMScust_tibble <- as_tibble (PUMScust_parsed)
  return (head (PUMScust_tibble))
}
getPUMSv3(2022,"GASP","HHL")
getPUMSv3(year=2022,numvarinput = "GASP")
```

Now except for the variables not being catorgorical but character, all other requirements are there.

## Make a function to specify the geographical level

We are interested in getting data with specific geographic levels and wanted to also specify the geographic items we are interested in (a specific region, district or state(s)). Checking the examples provided by the US census on the example URLs (https://api.census.gov/data/2022/acs/acs1/pums/examples.html):

Default call:
https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24&key=YOUR_KEY_GOES_HERE
To get the region-specific data: https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&for=region:*&SCHL=24&key=YOUR_KEY_GOES_HERE.
To get the division-specific data: https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&for=division:*&SCHL=24&key=YOUR_KEY_GOES_HERE 
To get the state-specific data: https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&for=state:*&SCHL=24&key=YOUR_KEY_GOES_HERE

It is easy to see the parameter here need to deal with is "for=XXX", which is included in the argument "query" in the function GET(). Thus we could let the new function specify this part. But after playing with it for a while we figured out in the query_params, geographic option should be included in the "get=" argument instead of "for=" argument because in R for is designated for the loop.

```{r}
getPUMSv4.0 <- function (year = 2022, numvarinput = "AGEP", catvarinput = "SEX") {
  base_url <- paste0 ("https://api.census.gov/data/", as.character(year), "/acs/acs1/pums")
  
  query_params <- list(
    get = paste0 (choosenum(numvarinput)[1],",",choosenum(numvarinput)[2],",",choosecat(catvarinput),",","REGION",",","ST",",","DIVISION"),
    SCHL = "24",
    key = "41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c")
  
  PUMScust <- httr::GET(url = base_url, query = query_params)
  PUMScust_parsed <- fromJSON(rawToChar(PUMScust$content))
  PUMScust_tibble <- as_tibble (PUMScust_parsed)
  return (head (PUMScust_tibble))
}
getPUMSv4.0(2022,"GASP","HHL")
```

For the ease of exercising, I directly input the level of geography in the previous function. Now we want to build a function to let user select geographic level as well as specify the region, division or state. Let's make a small function first.
```{r}
choosegeolvl <- function (geolvlinput) {
  if (geolvlinput %in% c("REGION", "DIVISION", "ST"))
  {geolvlvar <- geolvlinput}
  else {geolvlvar <- "Error"}
  return (geolvlvar)
}
choosegeolvl ("ST")
```

Now that we have the function to specify geographic level we want to display, integrate in the main function

```{r}
getPUMSv4.1 <- function (year = 2022, numvarinput = "AGEP", catvarinput = "SEX", geolvlinput = "All") {
  base_url <- paste0 ("https://api.census.gov/data/", as.character(year), "/acs/acs1/pums")
  
  query_params <- list(
    get = paste0 (choosenum(numvarinput)[1],",",choosenum(numvarinput)[2],",",choosecat(catvarinput),",",choosegeolvl(geolvlinput)),
    SCHL = "24",
    key = "41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c")
  
  PUMScust <- httr::GET(url = base_url, query = query_params)
  PUMScust_parsed <- fromJSON(rawToChar(PUMScust$content))
  PUMScust_tibble <- as_tibble (PUMScust_parsed)
  return (head (PUMScust_tibble))
}
getPUMSv4.1(2022,"GASP","HHL","ST")
```

Now let's enable an option to allow user to subset the data based on geographic information, and it must be on API. Considering the argument of query is essentially a list, which specifies "SCHL = "24"", we could try specify here as well.

```{r}
getPUMSv4.2 <- function (year = 2022, numvarinput = "AGEP", catvarinput = "SEX", geolvlinput = "All") {
  base_url <- paste0 ("https://api.census.gov/data/", as.character(year), "/acs/acs1/pums")
  
  query_params <- list(
    get = paste0 (choosenum(numvarinput)[1],",",choosenum(numvarinput)[2],",",choosecat(catvarinput),",",choosegeolvl(geolvlinput)),
    SCHL = "24",
    state = "17",
    key = "41b1ae36641c0a01c8cf9a48396a6c82ab8f6d9c")
  
  PUMScust <- httr::GET(url = base_url, query = query_params)
  PUMScust_parsed <- fromJSON(rawToChar(PUMScust$content))
  PUMScust_tibble <- as_tibble (PUMScust_parsed)
  return (head (PUMScust_tibble))
}
getPUMSv4.2(2022,"GASP","HHL","ST")
```






